## Отчет по лабораторной работе №2
#### № группы: 'ПМ-2402'
#### Выполнила: 'Тагирова Камилла Маратовна'
#### Выриант: '25'
### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

> Программа получает на вход 2 натуральных числа N, M и создает массив размера N на M, состоящий из логических выражений, пример: x < 5, где на месте логического знака могут быть >, < или =, справа всегда стоит число, а слева неизвестная x. После программа получает на вход натуральное число K и заменяет все неизвестные x в массиве на число K. Затем программа проверяет получившиеся логические выражения на истинность и выводи массив. Дальше программа сортирует строки массива по количеству истинных выражений в строке и выводит этот массив, заменяя истинные выражения на "Истина", а ложные на "Ложь". Дальше в программе подсчитывается количество уникальных правых частей всех логических выражений массива, и выводится этот подсчёт.

### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получать 3 числа. Два из них это размеры массива, поэтому отрицательными они быть не могут, а третье число, это число для логического выражение, оно может быть отрицательным.
(Я взяла число K, как натуральное, потому что в логических выражениях число справа натуральное.) 

|             | Тип                | min значение    | max значение             |
|-------------|--------------------|-----------------|--------------------------|
| N (Число 1) | Натуральное число  | 1               | 2<sup>31</sup> - 1       |
| M (Число 2) | Натуральное число  | 1               | 2<sup>31</sup> - 1       |
| K (Число 3) | Натуральное число  | -2<sup>31</sup> | 2<sup>31</sup> - 1<sup>  |

#### Данные на выход

Программа выводит массив результатов логических выражений, а значит создается массив типа boolean. А для подсчёта общего количества уникальных правых частей всех логических выражений будем использовать переменнную типа int.

|            | min значение    | max значение            |
|------------|-----------------|-------------------------|
| Массив     | -               | -                       |
| Число 1    | -2<sup>31</sup> | 2<sup>31</sup> - 1<sup> |

### 3. Выбор структуры данных

Программа получает 5 натуральных чисел, не превышающих по модулю  2<sup>31</sup> - 1<sup>. Поэтому для их хранения
можно выделить 5 переменных (`X`, `A`, `B`, `C` и `D`) типа `int`.

|             | Название переменной | Тип (в Java) | 
|-------------|---------------------|--------------|
| N (Число 1) | `N`                 | int          |
| M (Число 2) | `M`                 | int          |
| K (Число 3) | `K`                 | int          |

Для вывода результата неободимо выделить 2-е переменные для подсчёта количества упавших доминошек. 
В условии задачи указанно, что доминошек всего 5 и одну мы обязательно роняем, тогда для их хранения
можно выделить 2-е переменные (`cnt1` и `cnt2`) типа `int`.
|              | название переменной | Тип (в Java) | 
|--------------|---------------------|--------------|
| Массив       | `res`               | `boolean`    |
| cnt(Число 1) | `cnt`               | `int`        | 

### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает два натуральных числа, обозначенных как `N` и `M`.

2. **Создание переменных и ход программы**  
   Создаем двумерный массив, обозначенный как array размера N на M типа String. Считываем с клавиатуры логичесике выражения в этот массив. Создаем переменную типа int, обозначенную как K, для замены неизвестной (x) в логических выражениях в массиве array. Создаем массив типа boolean, обозначенный как res, для хранения результатов вычислений, а именно для результата логических выражений. Запускаем цикл в цикле, для вычисления истинности логичесих выражений и сохраняем эти результаты в созданный массив res, одновременно выводя этот массив. Для вычисления истинности логических выражений мы создаем подпрограмму, обозначенную как evaluateExpression типа boolean и  передаем туда наш изначально созданный массив array, в котором хранятся логические выражения, а также передаем переменную K, чтобы заменить неизвествую в логических выражениях на значение переменной K. После создаем подпрограмму sortRes, где сортируем массив res по количеству истинных выражений в строке, передавая туда получившийся массив res, а после выводим отсортированный массив res, заменняя истинные выражения на "Истина", а ложные на "Ложь". Остается только подсчитать количество уникальных правых частей. Для этого я создала подпрограмму cntRightParts, куда передается изначальный массив array с логическими выражениями, а возвращается количество, которое сразу выводится в клавной программе. 

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void sortRes(boolean[][] res) {
        int N = res.length;
        for (int i = 0; i < N - 1; i++) {
            for (int j = 0; j < N - 1 - i; j++) {
                int trueCnt1 = cntTrue(res[j]);
                int trueCnt2 = cntTrue(res[j + 1]);
                int falseCnt1 = res[j].length - trueCnt1;
                int falseCnt2 = res[j + 1].length - trueCnt2;
                if (trueCnt1 < trueCnt2 || (trueCnt1 == trueCnt2 && falseCnt1 > falseCnt2)) {
                    boolean[] temp = res[j];
                    res[j] = res[j + 1];
                    res[j + 1] = temp;
                }
            }
        }
    }
    public static int cntTrue(boolean[] row) {
        int cnt = 0;
        for (int i = 0; i < row.length; i++) {
            boolean value = row[i];
            if (value) {
                cnt++;
            }
        }
        return cnt;
    }
    public static boolean evaluateExpression(String array, int x) {
        String[] parts = array.split(" ");
        String oper = parts[1];            
        int num = Integer.parseInt(parts[2]);
        if (oper.equals(">"))
            return x > num;
        else if (oper.equals("<"))
            return x < num;
        else
            return x == num;
    }
    public static int cntRightParts(String[][] array) {
        String[] rightParts = new String[array.length * array[0].length]; 
        int cnt = 0;
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array[i].length; j++) {
                String rParts = array[i][j].split(" ")[2];
                boolean res = true;
                for (int k = 0; k < cnt; k++) {
                    if (rightParts[k].equals(rParts)) {
                        res = false;
                        break; 
                    }
                }
                if (res) {
                    rightParts[cnt] = rParts;
                    cnt++;
                }
            }
        }
        return cnt; 
    }
    public static void main(String[] args) {
        int N = in.nextInt();
        int M = in.nextInt();
        String[][] array = new String[N][M];
        in.nextLine();
        for (int i = 0; i < N; i++)
            for (int j = 0; j < M; j++)
                array[i][j] = in.nextLine();
        int K = in.nextInt();
        boolean[][] res = new boolean[N][M];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                res[i][j] = evaluateExpression(array[i][j], K);
                out.print(res[i][j] + " ");
            }
            out.println();
        }
        sortRes(res);
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (res[i][j] == true)
                    out.print("Истина");
                else
                    out.print("Ложь");
            }
            out.println();
        }
        out.println(cntRightParts(array));
    }
}
```

### 6. Анализ правильности решения

Программа работает корректно.

1. Тест на `N = 3`, `M = 2`, и логические выражения:
   
    - **Input**:
        ```
        3 2
        x < 6
        x > 3
        x = 4
        x > 6
        x < 7
        x = 5
        5
        ```

    - **Output**:
        ```
        true true
        false false
        true true
        Истина Истина
        Истина Истина
        Ложь Ложь
        5
        ```

2. Тест на `N = 2`, `M = 3`, и логические выражения:
   
    - **Input**:
        ```
        2 3
        x > 5
        x < 3
        x = 5
        x > 1
        x < 10
        x = 5
        5
        ```

    - **Output**:
        ```
        false false true
        true true true
        Истина Истина Истина
        Ложь Ложь Истина
        4 
        ```

3. Тест на `N = 3`, `M = 2`, и логические выражения:

    - **Input**:
        ```
        2 2
        x > 2
        x < 4
        x > 3
        x = 2
        3
        ```

    - **Output**:
        ```
        true true
        false false
        Истина Истина
        Ложь Ложь
        3
        ```

4. Тест на `N = 3`, `M = 1`, и логические выражения:

    - **Input**:
        ```
        3 1
        x < 7
        x = 4
        x > 6
        5
        ```

    - **Output**:
        ```
        true
        false
        false
        Истина
        Ложь
        Ложь
        3 
        ```

5. Тест на `N = 4`, `M = 3`, и логические выражения:

    - **Input**:
        ```
        4 3
        x > 2
        x < 5
        x = 3
        x > 4
        x < 6
        x = 7
        x > 6
        x = 4
        x < 10
        x < 3
        x = 5
        x > 1
        5
        ```

    - **Output**:
        ```
        true false false
        true true false
        false false true
        false true true
        Истина Истина Ложь
        Ложь Истина Истина
        Истина Ложь Ложь
        Ложь Ложь Истина
        8 
        ```
