## Отчет по лабораторной работе №2
#### № группы: 'ПМ-2402'
#### Выполнила: 'Тагирова Камилла Маратовна'
#### Выриант: '25'
### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

> Программа получает на вход 2 натуральных числа N, M и создает массив размера N на M, состоящий из логических выражений, пример: x < 5, где на месте логического знака могут быть >, < или =, справа всегда стоит число, а слева неизвестная x. После программа получает на вход натуральное число K и заменяет все неизвестные x в массиве на число K. Затем программа проверяет получившиеся логические выражения на истинность и выводит массив. Дальше программа сортирует строки массива по количеству истинных выражений в строке и выводит этот массив, заменяя истинные выражения на "Истина", а ложные на "Ложь". Дальше в программе подсчитывается количество уникальных правых частей всех логических выражений массива, и выводится этот подсчёт.

### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получать 3 числа. Два из них это размеры массива, поэтому отрицательными они быть не могут, а третье число, это число для логического выражение, оно может быть отрицательным.
(Я взяла число K, как натуральное, потому что в логических выражениях число справа натуральное.) Также размер массива не может равнять 0, поэтому минимальное значение переменных N и M возьмем равными за еденицу.

|             | Тип                | min значение    | max значение             |
|-------------|--------------------|-----------------|--------------------------|
| N (Число 1) | Натуральное число  | 1               | 2<sup>31</sup> - 1       |
| M (Число 2) | Натуральное число  | 1               | 2<sup>31</sup> - 1       |
| K (Число 3) | Натуральное число  | -2<sup>31</sup> | 2<sup>31</sup> - 1<sup>  |

#### Данные на выход

Программа выводит массив результатов логических выражений, а значит создается массив типа boolean. А для подсчёта общего количества уникальных правых частей всех логических выражений будем использовать переменнную типа int.

|            | min значение    | max значение            |
|------------|-----------------|-------------------------|
| Массив     | -               | -                       |
| Число 1    | -2<sup>31</sup> | 2<sup>31</sup> - 1<sup> |

### 2,5. Математическая модель
В главной программе нет определенных математических подсчётов, поэтому рассмотрим подпрограммы.
В подпрограмме cntRightParts происходит подсчёт уникальных правых частей всех логических выражений, туда передается наш массив с введенными логическими выражениями.
Мы создаем новый массив для хранения уникальных правых частей и заводим переменную cnt типа int как счётчик.
Запускаем цикл, в котором проходимся по элементам изначального массива (array, массив логических выражений). Создаем переменную типа String, которой присваиваем правую часть элемента массива.
Дальше проверяем, существует ли уже у нас такая правая часть, если нет, добавляем её в массив и увеличиваем счётчик, если да, то выходим из цикла и берем следующий элемент массива.
Теперь рассмотрим подпрограмму для подсчёта количества истинных выражений в строке.
В нее мы передаем строку, затем заводим счётчик и запускаем цикл, в котором проходимся по каждому элементу этой строки, то есть смотрим, сколько в строке истинных выражений. В конце возвращаем количество истинных выражений в строке в подпрограмму sortRes, которая сортирует массив по количеству истинных выражений в строке. 
В подпрограмме sortRes мы сортируем массив, сравнивая количество "Истина" в строке, если же количество совпадает, то смотрим на количество "Ложь".
Я считаю, что остальные подпрограммы нет смысла рассматривать, так как они несут в себе лишь логические выражения и вычисления. Никакой математики. 

### 3. Выбор структуры данных

Программа получает 3 натуральных числа, не превышающих по модулю  2<sup>31</sup> - 1<sup>. Поэтому для их хранения
можно выделить 3 переменные (`N`, `M`, `K`) типа `int`.

|             | Название переменной | Тип (в Java) | 
|-------------|---------------------|--------------|
| N (Число 1) | `N`                 | int          |
| M (Число 2) | `M`                 | int          |
| K (Число 3) | `K`                 | int          |

Для вывода результата неободимо создать массив, в котором будут храниться результаты логических выражений, а значит этот массив должен быть типа boolean и такого же размера, как размер массива с логическими выражениями, то есть N на M. 
А также нам требуется вывести количество уникальных правых частей всех логических выражений, поэтому необходимо создать переменную для подсчёта типа int, так как размер массива тоже типа int, а значит количество логических выражений в нем не будет превосходить допустимые значения типа int, но и более маленькие типы данных брать не стоит, так как массив может быть большим.

|               | название переменной | Тип (в Java) | 
|---------------|---------------------|--------------|
| Массив        | `res`               | `boolean`    |
| cnt (Число 1) | `cnt`               | `int`        | 

### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает два натуральных числа, обозначенных как `N` и `M`.

2. **Создание переменных и ход программы**  
   Создаем двумерный массив, обозначенный как array размера N на M типа String. Считываем с клавиатуры логичесике выражения в этот массив. Создаем переменную типа int, обозначенную как K, для замены неизвестной (x) в логических выражениях в массиве array. Создаем массив типа boolean, обозначенный как res, для хранения результатов вычислений, а именно для результата логических выражений. Запускаем цикл в цикле, для вычисления истинности логичесих выражений и сохраняем эти результаты в созданный массив res, одновременно выводя этот массив. Для вычисления истинности логических выражений мы создаем подпрограмму, обозначенную как evaluateArray типа boolean и  передаем туда наш изначально созданный массив array, в котором хранятся логические выражения, а также передаем переменную K, чтобы заменить неизвествую в логических выражениях на значение переменной K. После создаем подпрограмму sortRes, где сортируем массив res по количеству истинных выражений в строке, передавая туда получившийся массив res, а после выводим отсортированный массив res, заменняя истинные выражения на "Истина", а ложные на "Ложь". Остается только подсчитать количество уникальных правых частей. Для этого я создала подпрограмму cntRightParts, куда передается изначальный массив array с логическими выражениями, а возвращается количество, которое сразу выводится в главной программе. 

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    // Подпрограмма для сортировки массива по количеству истинных и ложных значений в строках
    public static void sortRes(boolean[][] res, String [][] array) {
        int N = res.length;
        // Сортировка
        for (int i = 0; i < N - 1; i++) {
            for (int j = 0; j < N - 1 - i; j++) {
                int trueCnt1 = cntTrue(res[j]);
                int trueCnt2 = cntTrue(res[j + 1]);
                int falseCnt1 = res[j].length - trueCnt1;
                int falseCnt2 = res[j + 1].length - trueCnt2;

                // Сравнение по количеству "Истина", если одинаково — по количеству "Ложь"
                if (trueCnt1 < trueCnt2 || (trueCnt1 == trueCnt2 && falseCnt1 > falseCnt2)) {
                    // Меняем строки местами, если они не в правильном порядке
                    boolean[] temp = res[j];
                    res[j] = res[j + 1];
                    res[j + 1] = temp;
                    String [] temp1 = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp1;
                }
            }
        }
    }
    // Подпрограмма для подсчета количества истинных выражений в строке
    public static int cntTrue(boolean[] row) {
        int cnt = 0;
        for (int i = 0; i < row.length; i++) {
            boolean value = row[i];
            if (value) {
                cnt++;
            }
        }
        return cnt;
    }
    // Подпрограмма для вычисления результата логического выражения
    public static boolean evaluateArray(String array, int x) {
        String[] parts = array.split(" "); // Разделяем строку на части
        String oper = parts[1];             // Получаем оператор (например, ">", "<", "=")
        int num = Integer.parseInt(parts[2]); // Получаем правую часть выражения (число)

        // Проверяем оператор
        if (oper.equals(">"))
            return x > num;
        else if (oper.equals("<"))
            return x < num;
        else
            return x == num;
    }

    // Подпрограмма для подсчета уникальных правых частей
    public static int cntRightParts(String[][] array) {
        String[] rightParts = new String[array.length * array[0].length]; // Массив для хранения уникальных правых частей
        int cnt = 0; // Счетчик
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array[i].length; j++) {
                String rParts = array[i][j].split(" ")[2]; // Получаем правую часть выражения
                // Проверяем, есть ли уже такая правая часть в массиве
                boolean res = true;
                for (int k = 0; k < cnt; k++) {
                    if (rightParts[k].equals(rParts)) {
                        res = false;
                        break; // Если нашли такую же, прекращаем проверку
                    }
                }
                // Если правая часть уникальна, добавляем её в массив
                if (res) {
                    rightParts[cnt] = rParts;
                    cnt++;
                }
            }
        }

        return cnt; // Возвращаем общее количество уникальных правых частей
    }
    public static void main(String[] args) {
        // Вводим размер массива
        int N = in.nextInt();
        int M = in.nextInt();
        String[][] array = new String[N][M];// Создаем двумерный массив строк для хранения логических выражений
        in.nextLine();
        // Ввод логических выражений
        for (int i = 0; i < N; i++)
            for (int j = 0; j < M; j++)
                array[i][j] = in.nextLine();
        int K = in.nextInt(); // Ввод значения переменной K
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                out.print(array[i][j] + " ");
            }
            out.println();
        }
        // Создаем массив для хранения результатов вычислений
        boolean[][] res = new boolean[N][M];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                // Вычисляем результат для каждого выражения, выводим и сохраняем его
                res[i][j] = evaluateArray(array[i][j], K);
                out.print(res[i][j] + " ");
            }
            out.println();
        }
        // Сортировка строк по количеству истинных и ложных значений
        sortRes(res, array);
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                out.print(array[i][j] + " ");
            }
            out.println();
        }
        // Вывод отсортированного массива
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (res[i][j])
                    out.print("Истина ");
                else
                    out.print("Ложь ");
            }
            out.println();
        }
        // Подсчитываем уникальные правые части и выводим
        out.println(cntRightParts(array));
    }
}
```

### 6. Анализ правильности решения

Программа работает корректно.

1. Тест на `N = 3`, `M = 2`, и логические выражения:
   
    - **Input**:
        ```
        3 2
        x < 6
        x > 3
        x = 4
        x > 6
        x < 7
        x = 5
        5
        ```

    - **Output**:
        ```
        x < 6 x > 3 
        x = 4 x > 6 
        x < 7 x = 5 
        true true 
        false false 
        true true 
        x < 6 x > 3 
        x < 7 x = 5 
        x = 4 x > 6 
        Истина Истина 
        Истина Истина 
        Ложь Ложь 
        5
        ```

2. Тест на `N = 2`, `M = 3`, и логические выражения:
   
    - **Input**:
        ```
        2 3
        x > 5
        x < 3
        x = 5
        x > 1
        x < 10
        x = 5
        5
        ```

    - **Output**:
        ```
        x > 5 x < 3 x = 5 
        x > 1 x < 10 x = 5 
        false false true 
        true true true 
        x > 1 x < 10 x = 5 
        x > 5 x < 3 x = 5 
        Истина Истина Истина 
        Ложь Ложь Истина 
        4
        ```

3. Тест на `N = 3`, `M = 2`, и логические выражения:

    - **Input**:
        ```
        2 2
        x > 2
        x < 4
        x > 3
        x = 2
        3
        ```

    - **Output**:
        ```
        x > 2 x < 4 
        x > 3 x = 2 
        true true 
        false false 
        x > 2 x < 4 
        x > 3 x = 2 
        Истина Истина 
        Ложь Ложь 
        3

        ```

4. Тест на `N = 3`, `M = 1`, и логические выражения:

    - **Input**:
        ```
        3 1
        x < 7
        x = 4
        x > 6
        5
        ```

    - **Output**:
        ```
        x < 7 
        x = 4 
        x > 6 
        true 
        false 
        false 
        x < 7 
        x = 4 
        x > 6 
        Истина 
        Ложь 
        Ложь 
        3
        ```

5. Тест на `N = 4`, `M = 3`, и логические выражения:

    - **Input**:
        ```
        4 3
        x > 2
        x < 5
        x = 3
        x > 4
        x < 6
        x = 7
        x > 6
        x = 4
        x < 10
        x < 3
        x = 5
        x > 1
        5
        ```

    - **Output**:
        ```
        true false false
        true true false
        false false true
        false true true
        x > 4 x < 6 x = 7 
        x < 3 x = 5 x > 1 
        x > 2 x < 5 x = 3 
        x > 6 x = 4 x < 10 
        Истина Истина Ложь
        Ложь Истина Истина
        Истина Ложь Ложь
        Ложь Ложь Истина
        8 
        ```
